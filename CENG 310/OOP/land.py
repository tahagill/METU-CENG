# -*- coding: utf-8 -*-
"""DSA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NnJerDvxkTPbJdsjOIWH9yVcQl5q4RjC
"""

class InvalidException(Exception):
    pass


class Stack:
    def __init__(self):
        self.data = []

    def __len__(self):
        return len(self.data)

    def is_empty(self):
        return len(self.data) == 0

    def push(self, e):
        self.data.append(e)

    def top(self):
        if self.is_empty():
            raise InvalidException("Stack is empty")
        return self.data[-1]

    def pop(self):
        if self.is_empty():
            raise InvalidException("Stack is empty")
        return self.data.pop()


class Land:
    def __init__(self, map):
        if len(map) <= 3:
            raise InvalidException("Map has to be larger than 3x3")

        row_len = len(map[0])
        if row_len <= 3:
            raise InvalidException("Rows must be larger than 3")

        for row in map:
            if len(row) != row_len:
                raise InvalidException('All rows must have the same length')

            for val in row:
                if val not in ['0', '1']:
                    raise InvalidException('Value must be either 0 or 1')
        self.map = map

    def get_start(self):
        for i in range(len(self.map)):
            for j in range(len(self.map[i])):
                if self.map[i][j] == '1':
                    return i, j
        return None

    def is_land(self, row, col):
        return 0 <= row < len(self.map) and 0 <= col < len(self.map[0]) and self.map[row][col] == '1'


import bisect

class IslandFinder:
    def __init__(self, path):
        self.land = self.text_to_array(path)
        self._cellstack = Stack()
        self._explored = []

    def text_to_array(self, path):
        with open(path, 'r') as file:
            return Land([list(line.strip()) for line in file])

    def find_largest_island(self):
        largest = 0
        for row in range(len(self.land.map)):
            for col in range(len(self.land.map[0])):
                if self.land.map[row][col] == '1' and not self.is_explored(row, col):
                    x = self.explore_island(row, col)
                    largest = max(largest, x)
        return largest

    def explore_island(self, row, col):
        x = 0
        self._cellstack.push((row, col))
        while not self._cellstack.is_empty():
            r, c = self._cellstack.pop()
            if not self.is_explored(r, c):
                self.mark_explored(r, c)
                x += 1
                for y, z in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    alpha_y, alpha_z = r + y, c + z
                    if self.land.is_land(alpha_y, alpha_z):
                        self._cellstack.push((alpha_y, alpha_z))
        return x

    def is_explored(self, row, col):
        index = bisect.bisect_left(self._explored, (row, col))
        return index < len(self._explored) and self._explored[index] == (row, col)

    def mark_explored(self, row, col):
        bisect.insort(self._explored, (row, col))

if __name__ == "__main__":
    finder = IslandFinder('test.txt')
    largest_island_size = finder.find_largest_island()
    print(f"Largest island size is: {largest_island_size}")